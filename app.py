import streamlit as st
from utils.prompts import (
    system_prompt,
    step_1_master_prompt,
    get_default_prompt_for_step
)
from utils.file_utils import read_file
from utils.openai_utils import generate_step_output
import json
import os
import html

DEFAULT_FILE_PATH = "Brand Inputs Master.txt"

def selections_to_html(selections):
    html_sections = []
    for step_key, step_data in selections.items():
        html_sections.append(f"<h2>{html.escape(step_key.replace('_', ' ').title())}</h2>")
        if isinstance(step_data, dict):
            html_sections.append("<ul>")
            for k, v in step_data.items():
                html_sections.append(f"<li><b>{html.escape(str(k))}:</b> {html.escape(str(v))}</li>")
            html_sections.append("</ul>")
        elif isinstance(step_data, list):
            for i, item in enumerate(step_data):
                html_sections.append(f"<h3>Option {i+1}</h3><ul>")
                if isinstance(item, dict):
                    for k, v in item.items():
                        html_sections.append(f"<li><b>{html.escape(str(k))}:</b> {html.escape(str(v))}</li>")
                else:
                    html_sections.append(f"<li>{html.escape(str(item))}</li>")
                html_sections.append("</ul>")
        else:
            html_sections.append(f"<p>{html.escape(str(step_data))}</p>")
    return "\n".join(html_sections)

# Helper to create unique keys for Streamlit
def make_key(field, idx):
    return f"{field}_{idx}_{st.session_state.step}"

# ---------- State Initialization ----------
if "step" not in st.session_state:
    st.session_state.step = 1
if "step_inputs" not in st.session_state:
    st.session_state.step_inputs = {}
if "step_outputs" not in st.session_state:
    st.session_state.step_outputs = {}
if "selections" not in st.session_state:
    st.session_state.selections = {}
if "messages" not in st.session_state:
    st.session_state.messages = [{"role": "system", "content": system_prompt}]

st.title("GPT Brand Strategy Generator")

if st.session_state.get("redo_flag"):
    st.info("This is a new set of outputs generated by the redo instruction. Please select your preferred options again.")
    st.session_state.redo_flag = False
    
with st.sidebar:
    st.title("üìù Progress Summary")
    if st.session_state.step > 1:
        for s in range(1, st.session_state.step):
            selection = st.session_state.selections.get(f"step_{s}")
            if selection:
                with st.expander(f"Step {s} Selections", expanded=False):
                    st.json(selection, expanded=False)
    else:
        st.write("No selections yet.")
        
# ----------- STEP 1 -----------
if st.session_state.step == 1:
    st.header("Step 1: Brand Basics")
    brand_name = st.text_input("Brand Name", value=st.session_state.step_inputs.get("brand_name", ""))
    brand_desc = st.text_area("Brand Description", value=st.session_state.step_inputs.get("brand_desc", ""))
    uploaded_file = st.file_uploader("Upload Document (PDF, DOCX, TXT)", type=["pdf", "docx", "txt"])

    if st.button("Next"):
        if not brand_name:
            st.error("Please fill in the Brand Name and upload a document.")
        else:
            if not uploaded_file:
                if os.path.exists(DEFAULT_FILE_PATH):
                    with open(DEFAULT_FILE_PATH, "r", encoding="utf-8") as f:
                        st.session_state.step_inputs["file_text"] = f.read()
                    # st.info("No file uploaded. Using local default file.")
                else:
                    st.error(f"Please upload a document or make sure '{DEFAULT_FILE_PATH}' exists.")
                    st.stop()
            else:
                st.session_state.step_inputs["file_text"] = read_file(uploaded_file)
            st.session_state.step_inputs["brand_name"] = brand_name
            st.session_state.step_inputs["brand_desc"] = brand_desc

            st.session_state.messages = [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": step_1_master_prompt},
                {"role": "user", "content": f"brand name: {brand_name}\nbrand_desc: {brand_desc}"},
                {"role": "user", "content": f"The content of the uploaded file: {st.session_state.step_inputs['file_text']}"},
            ]
            step_1_output = generate_step_output(st.session_state.messages)
            st.session_state.messages.append({
                "role": "assistant",
                "content": step_1_output
            })
            st.session_state.step_outputs["step_1"] = step_1_output
            st.session_state.step += 1
            st.rerun()

# ---------- STEP 2 ----------
if st.session_state.step == 2:
    st.header("Step 2: Select & Edit Your Core Directions")
    try:
        data = json.loads(st.session_state.step_outputs["step_1"])
    except Exception as e:
        st.error(f"Could not parse output as JSON: {e}")
        st.text_area("Raw Output", value=st.session_state.step_outputs["step_1"])
        st.stop()
    
    # 1. Show and edit the current prompt
    prompt_key = f"prompt_step_{st.session_state.step}"
    default_prompt = get_default_prompt_for_step(st.session_state.step)
    current_prompt = st.session_state.step_inputs.get(prompt_key, default_prompt)
    current_prompt = st.text_area("üîç **Current Prompt** (edit if needed):\n", value=current_prompt, key=prompt_key, height=400)
    st.session_state.step_inputs[prompt_key] = current_prompt

    # --- Business Core Ideas (Primary + Controversial, radio+editable) ---
    st.subheader("Business Core Idea")
    all_ideas = [
        {"label": f"[Primary] {x['micro_core_idea']} ‚Äî {x['expanded_core_idea']}", "type": "primary", "data": x}
        for x in data["business_core_ideas"]["primary_ideas"]
    ] + [
        {"label": f"[Controversial] {x['micro_core_idea']} ‚Äî {x['expanded_core_idea']}", "type": "controversial", "data": x}
        for x in data["business_core_ideas"]["controversial_ideas"]
    ]

    edited_ideas = []
    for idx, idea in enumerate(all_ideas):
        st.write(f"**Option {idx+1}:**")
        micro = st.text_input(
            f"Micro Core Idea {idx+1}", 
            value=idea["data"]["micro_core_idea"], 
            key=make_key("micro_core_idea", idx)
        )
        expanded = st.text_area(
            f"Expanded Core Idea {idx+1}", 
            value=idea["data"]["expanded_core_idea"], 
            key=make_key("expanded_core_idea", idx)
        )
        edited_ideas.append({"label": f"{micro} ‚Äî {expanded}", "type": idea["type"], "data": {"micro_core_idea": micro, "expanded_core_idea": expanded}})

    idea_choice_label = st.radio(
        "Choose one Business Core Idea", 
        [item["label"] for item in edited_ideas],
        key="business_core_idea_radio"
    )
    selected_idea = next((item for item in edited_ideas if item["label"] == idea_choice_label), None)

    # --- Why/How/What Statements (radio+editable) ---
    st.subheader("Why / How / What")
    all_whw = [
        {"label": f"[Primary] ‚Äî {x['why']} ‚Äî {x['how']} ‚Äî {x['what']}", "type": "primary", "data": x}
        for x in data["why_how_what_statements"]["primary_sets"]
    ] + [
        {"label": f"[Controversial] ‚Äî {x['why']} ‚Äî {x['how']} ‚Äî {x['what']}", "type": "controversial", "data": x}
        for x in data["why_how_what_statements"]["controversial_sets"]
    ]
    edited_whws = []
    for idx, whw in enumerate(all_whw):
        st.write(f"**Option {idx+1}:**")
        why = st.text_input(f"Why {idx+1}", value=whw["data"]["why"], key=make_key("whw_why", idx))
        how = st.text_input(f"How {idx+1}", value=whw["data"]["how"], key=make_key("whw_how", idx))
        what = st.text_input(f"What {idx+1}", value=whw["data"]["what"], key=make_key("whw_what", idx))
        edited_whws.append({"label": f"{why} ‚Äî {how} ‚Äî {what}", "type": whw["type"], "data": {"why": why, "how": how, "what": what}})

    whw_choice_label = st.radio(
        "Choose one Why/How/What", 
        [item["label"] for item in edited_whws],
        key="whw_radio"
    )
    selected_whw = next((item for item in edited_whws if item["label"] == whw_choice_label), None)

    # --- Problem/Solution Sets (radio+editable) ---
    st.subheader("Problem / Solution")
    all_solutions = [
        {"label": f"[Primary] ‚Äî {x['problem']} ‚Äî {x['solution']}", "type": "primary", "data": x}
        for x in data["problem_solution_sets"]["primary_sets"]
    ] + [
        {"label": f"[Controversial] ‚Äî {x['problem']} ‚Äî {x['solution']}", "type": "controversial", "data": x}
        for x in data["problem_solution_sets"]["controversial_sets"]
    ]
    edited_solutions = []
    for idx, sol in enumerate(all_solutions):
        st.write(f"**Option {idx+1}:**")
        problem = st.text_area(f"Problem {idx+1}", value=sol["data"]["problem"], key=make_key("prob", idx))
        solution = st.text_area(f"Solution {idx+1}", value=sol["data"]["solution"], key=make_key("sol", idx))
        edited_solutions.append({"label": f"{problem} ‚Äî {solution}", "type": sol["type"], "data": {"problem": problem, "solution": solution}})

    solution_choice_label = st.radio(
        "Choose one Problem/Solution", 
        [item["label"] for item in edited_solutions],
        key="solution_radio"
    )
    selected_solution = next((item for item in edited_solutions if item["label"] == solution_choice_label), None)

    # --- Tone Options (radio+editable) ---
    st.subheader("Tone Option")
    all_tones = [
        {"label": f"[Primary] {x}", "type": "primary", "data": x}
        for x in data["tone_options"]["primary_tones"]
    ] + [
        {"label": f"[Controversial] {x}", "type": "controversial", "data": x}
        for x in data["tone_options"]["controversial_tones"]
    ]
    edited_tones = []
    for idx, tone in enumerate(all_tones):
        tone_val = st.text_input(f"Tone Option {idx+1}", value=tone["data"], key=make_key("tone", idx))
        edited_tones.append({"label": tone_val, "type": tone["type"], "data": tone_val})

    tone_choice_label = st.radio(
        "Choose one Tone Option", 
        [item["label"] for item in edited_tones],
        key="tone_radio"
    )
    selected_tone = next((item for item in edited_tones if item["label"] == tone_choice_label), None)
    
    tools = [ { type: "web_search_preview" } ]
    
    # --- Submit Button ---
    if st.button("Next", key="go_to_step_2"):
        st.session_state.selections["step_2"] = {
            "business_core_idea": selected_idea,
            "whw": selected_whw,
            "solution": selected_solution,
            "tone": selected_tone,
        }
        st.session_state.step_inputs["step_2_context"] = f"""
            FOUNDATION PREFACE
            Use the following strategic selections from previous stages as non-negotiable foundations for all outputs. Every line should reflect and extend the logic, tone, and cultural position of this core strategy.
            {st.session_state.selections["step_2"]}
            Please ensure all responses in this prompt reflect and extend this foundation. Reject generic startup speak. Match the tone and strategic specificity of the Brand Inputs Master.
            {st.session_state.step_inputs[prompt_key]}
        """
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_2_context"]
        })
        step_2_output = generate_step_output(st.session_state.messages, tools)
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_2_output
        })
        st.session_state.step_outputs["step_2"] = step_2_output
        st.session_state.step += 1
        st.rerun()

    if st.button("Redo", key="redo_step_1_selections"):
        st.session_state.selections.pop("step_2", None)
        st.session_state.step_inputs["step_2_context"] = """
            REDO + EXPAND PROMPT
            Do again. Discard any outputs that feel off-tone, generic, or misaligned.
            Improve overall quality by:
            - Proposing alternate output styles, framings, or structures that better unlock the strategy
            - Exploring new metaphors, tones, or creative mechanisms that push the brand further
            - Avoiding repetition. Only reuse outputs if they are explicitly selected below.
            STRATEGY FOUNDATION TO FOLLOW  
            The outputs from previous work should be retained, adapted, or extended.
        """
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_2_context"]
        })
        step_2_output = generate_step_output(st.session_state.messages, tools)
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_2_output
        })
        st.session_state.step_outputs["step_1"] = step_2_output
        st.session_state.step = 2
        st.session_state.redo_flag = True
        st.rerun()

# ---------- STEP 3  ----------
if st.session_state.step == 3:
    st.header("Step 3: Select Cultural Layer Options")
    # --- 1. Editable prompt at top ---
    prompt_key = f"prompt_step_{st.session_state.step}"
    default_prompt = get_default_prompt_for_step(st.session_state.step)
    current_prompt = st.session_state.step_inputs.get(prompt_key, default_prompt)
    current_prompt = st.text_area("üß† Edit Prompt for This Step", value=current_prompt, key=prompt_key, height=400)
    st.session_state.step_inputs[prompt_key] = current_prompt

    # --- 2. Load data ---
    try:
        data = json.loads(st.session_state.step_outputs["step_2"])
    except Exception as e:
        st.error(f"Could not parse output as JSON: {e}")
        st.text_area("Raw Output", value=st.session_state.step_outputs["step_2"])
        st.stop()

    # --- 3. Editable + selectable options ---
    st.subheader("Story Archetype")
    archetype = data["story_archetype"]
    archetype_val = st.text_area("Story Archetype", value=archetype, key="brand_archetype_edit")

    st.subheader("Cult Words ‚Äì Alliterative")
    allit_words = data["cult_words"]["alliterative"]
    sel_allit = []
    edited_allit = []
    for idx, word in enumerate(allit_words):
        value = st.text_input(f"Alliterative Word {idx+1}", value=word, key=make_key("allit", idx))
        checked = st.checkbox("Select", key=make_key("allit_chk", idx))
        if checked:
            sel_allit.append(value)
        edited_allit.append(value)

    st.subheader("Operating Principles")
    operating = data["cult_words"]["operating_principles"]
    sel_oper = []
    edited_oper = []
    for idx, word in enumerate(operating):
        value = st.text_input(f"Operating Principle {idx+1}", value=word, key=make_key("oper", idx))
        checked = st.checkbox("Select", key=make_key("oper_chk", idx))
        if checked:
            sel_oper.append(value)
        edited_oper.append(value)

    st.subheader("Brand Persona")
    persona = data["brand_persona"]
    persona_val = st.text_area("Brand Persona", value=persona, key="brand_persona_edit")

    st.subheader("Competitors")
    competitors = [f"{c['name']}: {c['differentiation']}" for c in data["competitors"]]
    comp_choice = []
    edited_comps = []
    for idx, comp in enumerate(competitors):
        value = st.text_input(f"Competitor {idx+1}", value=comp, key=make_key("comp", idx))
        checked = st.checkbox("Select", key=make_key("comp_chk", idx))
        if checked:
            comp_choice.append(value)
        edited_comps.append(value)

    st.subheader("References")
    references = data["references"]
    sel_refs = []
    edited_refs = []
    for idx, ref in enumerate(references):
        value = st.text_input(f"Reference {idx+1}", value=ref, key=make_key("ref", idx))
        checked = st.checkbox("Select", key=make_key("ref_chk", idx))
        if checked:
            sel_refs.append(value)
        edited_refs.append(value)

    st.subheader("Red Flags")
    red_flags = data["red_flags"]
    sel_red_flags = []
    edited_flags = []
    for idx, flag in enumerate(red_flags):
        value = st.text_input(f"Red Flag {idx+1}", value=flag, key=make_key("redflag", idx))
        checked = st.checkbox("Select", key=make_key("redflag_chk", idx))
        if checked:
            sel_red_flags.append(value)
        edited_flags.append(value)

    # --- 4. Save + Next ---
    if st.button("Next", key="go_to_step_4"):
        st.session_state.selections["step_3"] = {
            "archetype": archetype_val,
            "alliterative": sel_allit,
            "operating_principles": sel_oper,
            "persona": persona_val,
            "competitors": comp_choice,
            "references": sel_refs,
            "red_flags": sel_red_flags
        }
        st.session_state.step_inputs["step_3_context"] = f"""
            FOUNDATION PREFACE
            Use the following strategic selections from previous stages as non-negotiable foundations for all outputs. Every line should reflect and extend the logic, tone, and cultural position of this core strategy.
            {st.session_state.selections["step_3"]}
            Please ensure all responses in this prompt reflect and extend this foundation. Reject generic startup speak. Match the tone and strategic specificity of the Brand Inputs Master.
            {st.session_state.step_inputs[prompt_key]}
        """
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_3_context"]
        })
        step_3_output = generate_step_output(st.session_state.messages)
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_3_output
        })
        st.session_state.step_outputs["step_3"] = step_3_output
        st.session_state.step += 1
        st.rerun()
        
    if st.button("Redo", key="redo_step_3_selections"):
        st.session_state.selections.pop("step_3", None)
        st.session_state.step_inputs["step_3_context"] = f"""
            REDO + EXPAND PROMPT
            Do again. Discard any outputs that feel off-tone, generic, or misaligned.
            Improve overall quality by:
            - Proposing alternate output styles, framings, or structures that better unlock the strategy
            - Exploring new metaphors, tones, or creative mechanisms that push the brand further
            - Avoiding repetition. Only reuse outputs if they are explicitly selected below.
            STRATEGY FOUNDATION TO FOLLOW  
            The outputs from previous work should be retained, adapted, or extended.
        """
        
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_3_context"]
        })
        step_3_output = generate_step_output(st.session_state.messages)
        
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_3_output
        })
        st.session_state.step_outputs["step_2"] = step_3_output
        st.session_state.step = 3
        st.session_state.redo_flag = True
        st.rerun()

# ----------- STEP 4-----------
if st.session_state.step == 4:
    st.header("Step 4: Select Brand Directions")

    # --- Editable prompt at top ---
    prompt_key = f"prompt_step_{st.session_state.step}"
    default_prompt = get_default_prompt_for_step(st.session_state.step)
    current_prompt = st.session_state.step_inputs.get(prompt_key, default_prompt)
    current_prompt = st.text_area("üß† Edit Prompt for This Step", value=current_prompt, key=prompt_key, height=400)
    st.session_state.step_inputs[prompt_key] = current_prompt

    # --- Load data ---
    try:
        data = json.loads(st.session_state.step_outputs["step_3"])
    except Exception as e:
        st.error(f"Could not parse output as JSON: {e}")
        st.text_area("Raw Output", value=st.session_state.step_outputs["step_3"])
        st.stop()

    brand_directions = data["brand_directions"]
    st.markdown("#### Review, edit, and select any directions that resonate as potential paths for the brand. (You can pick more than one!)")

    selected_directions = []
    for i, direction in enumerate(brand_directions):
        desc = st.text_area(f"Direction Description {i+1}", value=direction['description'], key=make_key("dir_desc", i))
        core_words = st.text_input(f"Core Words {i+1}", value=", ".join(direction['core_words']), key=make_key("dir_words", i))
        tag = st.text_input(f"Direction Tag {i+1}", value=direction['direction_tag'], key=make_key("dir_tag", i))
        checked = st.checkbox("Select this direction", key=make_key("dir_chk", i))
        edited = {"description": desc, "core_words": [w.strip() for w in core_words.split(",")], "direction_tag": tag}
        if checked:
            selected_directions.append(edited)

    if st.button("Next", key="go_to_step_5"):
        if not selected_directions:
            st.warning("Please select at least one direction to continue!")
            st.stop()
        st.session_state.selections["step_4"] = {
            "selected_brand_directions": selected_directions
        }
        
        st.session_state.step_inputs["step_4_context"] = f"""
            FOUNDATION PREFACE
            Use the following strategic selections from previous stages as non-negotiable foundations for all outputs. Every line should reflect and extend the logic, tone, and cultural position of this core strategy.
            {st.session_state.selections["step_4"]}
            Please ensure all responses in this prompt reflect and extend this foundation. Reject generic startup speak. Match the tone and strategic specificity of the Brand Inputs Master.
            {st.session_state.step_inputs[prompt_key]}
        """
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_4_context"]
        })
        step_4_output = generate_step_output(st.session_state.messages)
        st.session_state.step_outputs["step_4"] = step_4_output
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_4_output
        })
        st.session_state.step += 1
        st.rerun()
        
    if st.button("Redo", key="redo_step_4_selections"):
        st.session_state.selections.pop("step_4", None)
        st.session_state.step_inputs["step_4_context"] = f"""
            FOLLOW DIRECTION STRONGER PROMPT

            Do again. Match the tone, style, and strategic logic more tightly to the chosen direction.

            STRATEGY FOUNDATION TO FOLLOW  

            Use the previous strategy selections as the non-negotiable foundation for this direction extension. Every line should reflect and extend the logic, tone, and emotional core of this strategy.

            EXECUTION RULES  

            Reject startup clich√©s. Match or exceed the poetic clarity and strategic sharpness of the *Brand Inputs Master*. Prioritize metaphor, cultural insight, and product-backed symbolism. No filler.
        """
        
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_4_context"]
        })
        step_4_output = generate_step_output(st.session_state.messages)
        
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_4_output
        })
        st.session_state.step_outputs["step_3"] = step_4_output
        st.session_state.step = 4
        st.session_state.redo_flag = True
        st.rerun()
        
# ----------- STEP 5 -----------
if st.session_state.step == 5:
    st.header("Step 5: Select Company Names")

    # --- Editable prompt at top ---
    prompt_key = f"prompt_step_{st.session_state.step}"
    default_prompt = get_default_prompt_for_step(st.session_state.step)
    current_prompt = st.session_state.step_inputs.get(prompt_key, default_prompt)
    current_prompt = st.text_area("üß† Edit Prompt for This Step", value=current_prompt, key=prompt_key, height=400)
    st.session_state.step_inputs[prompt_key] = current_prompt

    # --- Load data ---
    try:
        data = json.loads(st.session_state.step_outputs["step_4"])  # Output from Prompt 4
    except Exception as e:
        st.error(f"Could not parse output as JSON: {e}")
        st.text_area("Raw Output", value=st.session_state.step_outputs["step_4"])
        st.stop()

    st.markdown("#### Review the candidate company names from each naming style below. Edit as needed and select your favorite(s) to continue.")

    selected_names = {"strategic_style": [], "special_wrongness_style": [], "best_namer_method": []}

    for style_key, style_label in [
        ("strategic_style", "Strategic Style"),
        ("special_wrongness_style", "Special Wrongness Style"),
        ("best_namer_method", "Best Namer Method"),
    ]:
        st.subheader(style_label)
        for i, item in enumerate(data[style_key]):
            name_val = st.text_input(f"Name {style_label} #{i+1}", value=item["name"], key=make_key(f"{style_key}_name", i))
            note_val = st.text_input(f"Note {style_label} #{i+1}", value=item.get("note", ""), key=make_key(f"{style_key}_note", i))
            status_val = st.text_input(f"Status {style_label} #{i+1}", value=item.get("status", ""), key=make_key(f"{style_key}_status", i))
            checked = st.checkbox("Select this name", key=make_key(f"{style_key}_chk", i))
            edited_item = {"name": name_val, "note": note_val, "status": status_val}
            if checked:
                selected_names[style_key].append(edited_item)

    if st.button("Next", key="go_to_step_6"):
        total_selected = sum(len(v) for v in selected_names.values())
        if total_selected == 0:
            st.warning("Please select at least one company name to continue!")
            st.stop()
        st.session_state.selections["step_5"] = selected_names
        st.session_state.step_inputs["step_5_context"] = f"""
            FOUNDATION PREFACE
            Use the following strategic selections from previous stages as non-negotiable foundations for all outputs. Every line should reflect and extend the logic, tone, and cultural position of this core strategy.
            {st.session_state.selections["step_4"]}
            Please ensure all responses in this prompt reflect and extend this foundation. Reject generic startup speak. Match the tone and strategic specificity of the Brand Inputs Master.
            {st.session_state.step_inputs[prompt_key]}
        """
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_5_context"]
        })
        step_5_output = generate_step_output(st.session_state.messages)
        st.session_state.step_outputs["step_5"] = step_5_output
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_5_output
        })
        st.session_state.step += 1
        st.rerun()
        
    if st.button("Redo", key="redo_step_5_selections"):
        st.session_state.selections.pop("step_5", None)
        st.session_state.step_inputs["step_5_context"] = f"""
            FOLLOW DIRECTION STRONGER PROMPT

            Do again. Match the tone, style, and strategic logic more tightly to the chosen direction.

            STRATEGY FOUNDATION TO FOLLOW  

            Use the previous strategy selections as the non-negotiable foundation for this direction extension. Every line should reflect and extend the logic, tone, and emotional core of this strategy.

            EXECUTION RULES  

            Reject startup clich√©s. Match or exceed the poetic clarity and strategic sharpness of the *Brand Inputs Master*. Prioritize metaphor, cultural insight, and product-backed symbolism. No filler.
        """
        
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_5_context"]
        })
        step_5_output = generate_step_output(st.session_state.messages)
        
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_5_output
        })
        st.session_state.step_outputs["step_4"] = step_5_output
        st.session_state.step = 5
        st.session_state.redo_flag = True
        st.rerun()
        
# ----------- STEP 6 -----------
if st.session_state.step == 6:
    st.header("Step 6: Review & Select Creative Copies")
    
    # --- Load data and handle missing keys ---
    try:
        data = json.loads(st.session_state.step_outputs["step_5"])
    except Exception as e:
        st.error(f"Could not parse output as JSON: {e}")
        st.text_area("Raw Output", value=st.session_state.step_outputs["step_5"])
        st.stop()

    direction_copies = data.get("direction_copies")
    if not direction_copies:
        st.error("No 'direction_copies' found in previous step's output. Here is the raw data for debugging.")
        st.text_area("Raw Step 5 Output", value=st.session_state.step_outputs["step_5"])
        st.stop()

    st.markdown("#### Review, edit, and **select** the creative copy explorations you want to keep.")

    selected_creative_copies = []
    for i, copy in enumerate(direction_copies):
        st.markdown(f"---\n### Creative Copy {i+1}")

        dir_val = st.text_input(f"Direction {i+1}", value=copy.get("direction", ""), key=make_key("copy_dir", i))
        setup_lines_val = st.text_area(f"Setup Lines {i+1}", value="\n".join(copy.get("setup_lines", [])), key=make_key("copy_setup", i))
        manifesto_val = st.text_area(f"Manifesto {i+1}", value=copy.get("manifesto", ""), key=make_key("copy_manifesto", i))
        headline_set_val = st.text_area(f"Headline Set {i+1}", value="\n".join(copy.get("headline_set", [])), key=make_key("copy_headline", i))

        checked = st.checkbox("Include this Creative Copy", key=make_key("copy_chk", i))
        if checked:
            selected_creative_copies.append({
                "direction": dir_val,
                "setup_lines": [line.strip() for line in setup_lines_val.split("\n") if line.strip()],
                "manifesto": manifesto_val,
                "headline_set": [line.strip() for line in headline_set_val.split("\n") if line.strip()]
            })
            
    if st.button("Export Selections as HTML", key="confirm_finish"):
        if not selected_creative_copies:
            st.warning("Please select at least one Creative Copy to confirm!")
            st.stop()
        st.session_state.selections["step_6"] = selected_creative_copies
        html_content = f"""
        <html>
            <head>
                <meta charset="utf-8">
                <title>Brand Strategy Selections</title>
                <style>
                    body {{ font-family: Arial, sans-serif; margin: 40px; }}
                    h2 {{ color: #007bfc; }}
                    ul {{ margin-bottom: 20px; }}
                    li {{ margin-bottom: 8px; }}
                </style>
            </head>
            <body>
                <h1>Brand Strategy Selections</h1>
                {selections_to_html(st.session_state.selections)}
            </body>
        </html>
        """
        st.download_button(
            label="Download as HTML",
            data=html_content,
            file_name="brand_strategy_selections.html",
            mime="text/html"
        )
        st.success("Congratulations! Your brand platform is complete.")

    if st.button("Redo", key="redo_step_5"):
        st.session_state.step_inputs["step_6_context"] = f"""
            REDO + EXPAND PROMPT
            Do again. Discard any outputs that feel off-tone, generic, or misaligned.
            Improve overall quality by:
            - Proposing alternate output styles, framings, or structures that better unlock the strategy
            - Exploring new metaphors, tones, or creative mechanisms that push the brand further
            - Avoiding repetition. Only reuse outputs if they are explicitly selected below.
            STRATEGY FOUNDATION TO FOLLOW  
            The outputs from previous work should be retained, adapted, or extended.
        """
        
        st.session_state.messages.append({
            "role": "user",
            "content": st.session_state.step_inputs["step_6_context"]
        })
        step_6_output = generate_step_output(st.session_state.messages)
        
        st.session_state.messages.append({
            "role": "assistant",
            "content": step_6_output
        })
        st.session_state.step_outputs["step_5"] = step_6_output
        st.session_state.step = 6
        st.session_state.redo_flag = True
        st.rerun()
